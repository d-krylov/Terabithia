#version 460 core

// INPUT
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// OUTPUT
layout(rgba32f, binding = 0) uniform image2D u_image_output;

// UNIFORM
layout (location = 0) uniform float iTime;
layout (location = 1) uniform ivec2 iResolution;

// CONSTANTS
#define EPSILON    (0.001)
#define TERRAIN_ID (0.0)
	
// STRUCT
struct Ray {
  vec3 origin;
  vec3 direction;
};

struct Hit {
  float id;
  vec3 position;
  vec3 normal;
};

// NOISE

float random1f(vec2 p) {
  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);
}

vec3 noise(vec2 x) {
  vec2 i = floor(x);
  vec2 f = fract(x);
  vec2 u = f * f * (3.0 - 2.0 * f);
  vec2 du = 6.0 * f * (1.0 - f);
  
  float a = random1f(i + vec2(0.0, 0.0));
  float b = random1f(i + vec2(1.0, 0.0));
  float c = random1f(i + vec2(0.0, 1.0));
  float d = random1f(i + vec2(1.0, 1.0));
  
  vec2 df = du * (vec2(b - a, c - a) + (a - b - c + d) * u.yx);

  return vec3(mix(mix(a, b, u.x), mix(c, d, u.x), u.y), df);
}

vec3 fbm(vec2 x, float H, int octaves) {    
  float g = pow(2.0, -H);
  float f = 1.0;
  float a = 1.0;
  float r = 0.0;
  vec2 d = vec2(0.0);
  for (int i = 0; i < octaves; i++) {
    vec3 n = noise(f * x);
    r += a * n.x;
    f *= 2.0;
    d += n.yz;
    a *= g;
  }
  return vec3(r, d);
}

//SCENE

vec3 NORMAL;

vec2 terrain(vec3 p) {
  float m1 = 0.005, m2 = 0.01, m3 = 0.02, m4 = 0.06;
  vec3 h1 = 90.0 * fbm(m1 * p.xz, 0.7, 3);
  vec3 h2 = 50.0 * fbm(m2 * p.xz, 0.5, 4);
  vec3 h3 = 10.0 * fbm(m3 * p.xz, 0.3, 5);
  vec3 h4 = 1.00 * fbm(m4 * p.xz, 0.3, 6);
  vec3 h = h1 + h2 + h3 + h4;
  vec2 d = m1 * h1.yz + m2 * h2.yz + m3 * h3.yz + m4 * h4.yz;
  NORMAL = vec3(-d.x, 1.0, -d.y);
  NORMAL = normalize(NORMAL);

  return vec2(p.y - h.x, TERRAIN_ID);
}


vec2 map(vec3 p) {
  vec2 ret = terrain(p);

  return ret;
}

// https://iquilezles.org/articles/normalsSDF/

vec3 get_normal(vec3 p) {
  const float h = 0.001; 
  const vec2 k = vec2(1.0, -1.0);
  return normalize(k.xyy * map(p + k.xyy * h).x + 
                   k.yyx * map(p + k.yyx * h).x + 
                   k.yxy * map(p + k.yxy * h).x + 
                   k.xxx * map(p + k.xxx * h).x);
}

// MARCH
Hit march(Ray ray, float near, float far, float step_size, int step_count) {
  Hit hit; 
  hit.id = -1.0;
  float t = near;
  for (int i = 0; i < step_count && t < far; i++) {
    vec3 p = ray.origin + ray.direction * t;
    vec2 d = map(p);
    if (d.x < EPSILON) {
      hit.id = d.y;
      hit.position = p;
      hit.normal = NORMAL;
      break;
    }
    t += step_size * d.x;
  }
  return hit;
}


vec3 render(Ray ray) {
  vec3 color = vec3(0.0);

  vec3 sun_direction = normalize(vec3(1.0, 10.0, 10.0));

  Hit hit = march(ray, 0.0, 5000.0, 0.5, 1000);

  if (hit.id != -1.0) {
    float NdoR = max(dot(hit.normal, sun_direction), 0.0);
    color = vec3(0.2) + vec3(0.4, 0.1, 0.1) * NdoR;
  }

  return color;
}

void main() {
  vec2 uv = gl_GlobalInvocationID.xy;

  vec2 screen = (2.0 * uv - iResolution) / iResolution.y;

  Ray ray;
  ray.origin = vec3(0.0, 200.0, 4.0);
  ray.direction = normalize(vec3(screen, -1.0)); 

  vec3 color = render(ray);

  imageStore(u_image_output, ivec2(uv), vec4(color, 1.0));
}