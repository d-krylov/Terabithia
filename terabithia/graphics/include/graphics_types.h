#ifndef TERABITHIA_GRAPHICS_TYPES_H
#define TERABITHIA_GRAPHICS_TYPES_H

#include "glad/glad.h"
#include "terabithia/core/include/descriptor.h"
#include "terabithia/core/include/mask.h"
#include "terabithia/core/include/core.h"
#include <string_view>
#include <span>

namespace Terabithia {

using Handle = uint32_t;

// DEBUG

enum class ErrorCode : uint32_t {
  NO_ERROR = GL_NO_ERROR,
  INVALID_ENUM = GL_INVALID_ENUM,
  INVALID_VALUE = GL_INVALID_VALUE,
  INVALID_OPERATION = GL_INVALID_OPERATION,
  INVALID_FRAMEBUFFER_OPERATION = GL_INVALID_FRAMEBUFFER_OPERATION,
  OUT_OF_MEMORY = GL_OUT_OF_MEMORY,
  STACK_UNDERFLOW = GL_STACK_UNDERFLOW,
  STACK_OVERFLOW = GL_STACK_OVERFLOW
};

// VERTEX ARRAY

enum class VertexAttributeType {
  BYTE = GL_BYTE,
  SHORT = GL_SHORT,
  INT = GL_INT,
  FIXED = GL_FIXED,
  FLOAT = GL_FLOAT,
  HALF_FLOAT = GL_HALF_FLOAT,
  DOUBLE = GL_DOUBLE,
  UNSIGNED_BYTE = GL_UNSIGNED_BYTE,
  UNSIGNED_SHORT = GL_UNSIGNED_SHORT,
  UNSIGNED_INT = GL_UNSIGNED_INT,
  INT_2_10_10_10_REV = GL_INT_2_10_10_10_REV,
  UNSIGNED_INT_2_10_10_10_REV = GL_UNSIGNED_INT_2_10_10_10_REV,
  UNSIGNED_INT_10F_11F_11F_REV = GL_UNSIGNED_INT_10F_11F_11F_REV
};

enum class AttributeType {
  FLOAT = GL_FLOAT,
  FLOAT_VEC2 = GL_FLOAT_VEC2,
  FLOAT_VEC3 = GL_FLOAT_VEC3,
  FLOAT_VEC4 = GL_FLOAT_VEC4,
  FLOAT_MAT2 = GL_FLOAT_MAT2,
  FLOAT_MAT3 = GL_FLOAT_MAT3,
  FLOAT_MAT4 = GL_FLOAT_MAT4,
  FLOAT_MAT2x3 = GL_FLOAT_MAT2x3,
  FLOAT_MAT2x4 = GL_FLOAT_MAT2x4,
  FLOAT_MAT3x2 = GL_FLOAT_MAT3x2,
  FLOAT_MAT3x4 = GL_FLOAT_MAT3x4,
  FLOAT_MAT4x2 = GL_FLOAT_MAT4x2,
  FLOAT_MAT4x3 = GL_FLOAT_MAT4x3,
  INT = GL_INT,
  INT_VEC2 = GL_INT_VEC2,
  INT_VEC3 = GL_INT_VEC3,
  INT_VEC4 = GL_INT_VEC4,
  UNSIGNED_INT = GL_UNSIGNED_INT,
  UNSIGNED_INT_VEC2 = GL_UNSIGNED_INT_VEC2,
  UNSIGNED_INT_VEC3 = GL_UNSIGNED_INT_VEC3,
  UNSIGNED_INT_VEC4 = GL_UNSIGNED_INT_VEC4,
  DOUBLE = GL_DOUBLE,
  DOUBLE_VEC2 = GL_DOUBLE_VEC2,
  DOUBLE_VEC3 = GL_DOUBLE_VEC3,
  DOUBLE_VEC4 = GL_DOUBLE_VEC4,
  DOUBLE_MAT2 = GL_DOUBLE_MAT2,
  DOUBLE_MAT3 = GL_DOUBLE_MAT3,
  DOUBLE_MAT4 = GL_DOUBLE_MAT4,
  DOUBLE_MAT2x3 = GL_DOUBLE_MAT2x3,
  DOUBLE_MAT2x4 = GL_DOUBLE_MAT2x4,
  DOUBLE_MAT3x2 = GL_DOUBLE_MAT3x2,
  DOUBLE_MAT3x4 = GL_DOUBLE_MAT3x4,
  DOUBLE_MAT4x2 = GL_DOUBLE_MAT4x2,
  DOUBLE_MAT4x3 = GL_DOUBLE_MAT4x3
};

// BUFFER

enum class BufferStorageMaskBit {
  DYNAMIC = GL_DYNAMIC_STORAGE_BIT,
  MAP_READ = GL_MAP_READ_BIT,
  MAP_WRITE = GL_MAP_WRITE_BIT,
  MAP_PERSISTENT = GL_MAP_PERSISTENT_BIT,
  MAP_COHERENT = GL_MAP_COHERENT_BIT,
  CLIENT_STORAGE = GL_CLIENT_STORAGE_BIT
};

enum class MapBufferAccessMaskBit {
  MAP_READ = GL_MAP_READ_BIT,
  MAP_WRITE = GL_MAP_WRITE_BIT,
  MAP_PERSISTENT = GL_MAP_PERSISTENT_BIT,
  MAP_COHERENT = GL_MAP_COHERENT_BIT,
  MAP_INVALIDATE_RANGE = GL_MAP_INVALIDATE_RANGE_BIT,
  MAP_INVALIDATE_BUFFER = GL_MAP_INVALIDATE_BUFFER_BIT,
  MAP_FLUSH_EXPLICIT = GL_MAP_FLUSH_EXPLICIT_BIT,
  MAP_UNSYNCHRONIZED = GL_MAP_UNSYNCHRONIZED_BIT
};

enum class MapBufferAccess : uint32_t {
  READ_ONLY = GL_READ_ONLY,
  WRITE_ONLY = GL_WRITE_ONLY,
  READ_WRITE = GL_READ_WRITE
};

// TEXTURE

enum class TextureTarget : uint32_t {
  TEXTURE_1D = GL_TEXTURE_1D,
  TEXTURE_2D = GL_TEXTURE_2D,
  TEXTURE_3D = GL_TEXTURE_3D,
  TEXTURE_1D_ARRAY = GL_TEXTURE_1D_ARRAY,
  TEXTURE_2D_ARRAY = GL_TEXTURE_2D_ARRAY,
  TEXTURE_RECTANGLE = GL_TEXTURE_RECTANGLE,
  TEXTURE_CUBE_MAP = GL_TEXTURE_CUBE_MAP,
  TEXTURE_CUBE_MAP_ARRAY = GL_TEXTURE_CUBE_MAP_ARRAY,
  TEXTURE_BUFFER = GL_TEXTURE_BUFFER,
  TEXTURE_2D_MULTISAMPLE = GL_TEXTURE_2D_MULTISAMPLE,
  TEXTURE_2D_MULTISAMPLE_ARRAY = GL_TEXTURE_2D_MULTISAMPLE_ARRAY
};

enum class TextureParameterName : uint32_t {
  DEPTH_STENCIL_TEXTURE_MODE = GL_DEPTH_STENCIL_TEXTURE_MODE,
  TEXTURE_BASE_LEVEL = GL_TEXTURE_BASE_LEVEL,
  TEXTURE_COMPARE_FUNC = GL_TEXTURE_COMPARE_FUNC,
  TEXTURE_COMPARE_MODE = GL_TEXTURE_COMPARE_MODE,
  TEXTURE_LOD_BIAS = GL_TEXTURE_LOD_BIAS,
  TEXTURE_MIN_FILTER = GL_TEXTURE_MIN_FILTER,
  TEXTURE_MAG_FILTER = GL_TEXTURE_MAG_FILTER,
  TEXTURE_MIN_LOD = GL_TEXTURE_MIN_LOD,
  TEXTURE_MAX_LOD = GL_TEXTURE_MAX_LOD,
  TEXTURE_MAX_LEVEL = GL_TEXTURE_MAX_LEVEL,
  TEXTURE_SWIZZLE_R = GL_TEXTURE_SWIZZLE_R,
  TEXTURE_SWIZZLE_G = GL_TEXTURE_SWIZZLE_G,
  TEXTURE_SWIZZLE_B = GL_TEXTURE_SWIZZLE_B,
  TEXTURE_SWIZZLE_A = GL_TEXTURE_SWIZZLE_A,
  TEXTURE_WRAP_S = GL_TEXTURE_WRAP_S,
  TEXTURE_WRAP_T = GL_TEXTURE_WRAP_T,
  TEXTURE_WRAP_R = GL_TEXTURE_WRAP_R
};

enum class MinFilter : uint32_t {
  NEAREST = GL_NEAREST,
  LINEAR = GL_LINEAR,
  NEAREST_MIPMAP_NEAREST = GL_NEAREST_MIPMAP_NEAREST,
  LINEAR_MIPMAP_NEAREST = GL_LINEAR_MIPMAP_NEAREST,
  NEAREST_MIPMAP_LINEAR = GL_NEAREST_MIPMAP_LINEAR,
  LINEAR_MIPMAP_LINEAR = GL_LINEAR_MIPMAP_LINEAR
};

enum class MagFilter : uint32_t {
  NEAREST = GL_NEAREST,
  LINEAR = GL_LINEAR
};

enum class TextureWrapMode : uint32_t {
  CLAMP_TO_EDGE = GL_CLAMP_TO_EDGE,
  CLAMP_TO_BORDER = GL_CLAMP_TO_BORDER,
  MIRRORED_REPEAT = GL_MIRRORED_REPEAT,
  REPEAT = GL_REPEAT,
  MIRROR_CLAMP_TO_EDGE = GL_MIRROR_CLAMP_TO_EDGE
};

enum class InternalFormat {
  R8 = GL_R8,
  R8_SNORM = GL_R8_SNORM,
  R16 = GL_R16,
  R16_SNORM = GL_R16_SNORM,
  RG8 = GL_RG8,
  RG8_SNORM = GL_RG8_SNORM,
  RG16 = GL_RG16,
  RG16_SNORM = GL_RG16_SNORM,
  R3_G3_B2 = GL_R3_G3_B2,
  RGB4 = GL_RGB4,
  RGB5 = GL_RGB5,
  RGB8 = GL_RGB8,
  RGB8_SNORM = GL_RGB8_SNORM,
  RGB10 = GL_RGB10,
  RGB12 = GL_RGB12,
  RGB16_SNORM = GL_RGB16_SNORM,
  RGBA2 = GL_RGBA2,
  RGBA4 = GL_RGBA4,
  RGB5_A1 = GL_RGB5_A1,
  RGBA8 = GL_RGBA8,
  RGBA8_SNORM = GL_RGBA8_SNORM,
  RGB10_A2 = GL_RGB10_A2,
  RGB10_A2UI = GL_RGB10_A2UI,
  RGBA12 = GL_RGBA12,
  RGBA16 = GL_RGBA16,
  SRGB8 = GL_SRGB8,
  SRGB8_ALPHA8 = GL_SRGB8_ALPHA8,
  R16F = GL_R16F,
  RG16F = GL_RG16F,
  RGB16F = GL_RGB16F,
  RGBA16F = GL_RGBA16F,
  R32F = GL_R32F,
  RG32F = GL_RG32F,
  RGB32F = GL_RGB32F,
  RGBA32F = GL_RGBA32F,
  R11F_G11F_B10F = GL_R11F_G11F_B10F,
  RGB9_E5 = GL_RGB9_E5,
  R8I = GL_R8I,
  R8UI = GL_R8UI,
  R16I = GL_R16I,
  R16UI = GL_R16UI,
  R32I = GL_R32I,
  R32UI = GL_R32UI,
  RG8I = GL_RG8I,
  RG8UI = GL_RG8UI,
  RG16I = GL_RG16I,
  RG16UI = GL_RG16UI,
  RG32I = GL_RG32I,
  RG32UI = GL_RG32UI,
  RGB8I = GL_RGB8I,
  RGB8UI = GL_RGB8UI,
  RGB16I = GL_RGB16I,
  RGB16UI = GL_RGB16UI,
  RGB32I = GL_RGB32I,
  RGB32UI = GL_RGB32UI,
  RGBA8I = GL_RGBA8I,
  RGBA8UI = GL_RGBA8UI,
  RGBA16I = GL_RGBA16I,
  RGBA16UI = GL_RGBA16UI,
  RGBA32I = GL_RGBA32I,
  RGBA32UI = GL_RGBA32UI
};

enum class PixelFormat {
  RED = GL_RED,
  RG = GL_RG,
  RGB = GL_RGB,
  BGR = GL_BGR,
  RGBA = GL_RGBA,
  BGRA = GL_BGRA,
  DEPTH_COMPONENT = GL_DEPTH_COMPONENT,
  STENCIL_INDEX = GL_STENCIL_INDEX
};

enum class PixelType {
  UNSIGNED_BYTE = GL_UNSIGNED_BYTE,
  BYTE = GL_BYTE,
  UNSIGNED_SHORT = GL_UNSIGNED_SHORT,
  SHORT = GL_SHORT,
  UNSIGNED_INT = GL_UNSIGNED_INT,
  INT = GL_INT,
  FLOAT = GL_FLOAT,
  UNSIGNED_BYTE_3_3_2 = GL_UNSIGNED_BYTE_3_3_2,
  UNSIGNED_BYTE_2_3_3_REV = GL_UNSIGNED_BYTE_2_3_3_REV,
  UNSIGNED_SHORT_5_6_5 = GL_UNSIGNED_SHORT_5_6_5,
  UNSIGNED_SHORT_5_6_5_REV = GL_UNSIGNED_SHORT_5_6_5_REV,
  UNSIGNED_SHORT_4_4_4_4 = GL_UNSIGNED_SHORT_4_4_4_4,
  UNSIGNED_SHORT_4_4_4_4_REV = GL_UNSIGNED_SHORT_4_4_4_4_REV,
  UNSIGNED_SHORT_5_5_5_1 = GL_UNSIGNED_SHORT_5_5_5_1,
  UNSIGNED_SHORT_1_5_5_5_REV = GL_UNSIGNED_SHORT_1_5_5_5_REV,
  UNSIGNED_INT_8_8_8_8 = GL_UNSIGNED_INT_8_8_8_8,
  UNSIGNED_INT_8_8_8_8_REV = GL_UNSIGNED_INT_8_8_8_8_REV,
  UNSIGNED_INT_10_10_10_2 = GL_UNSIGNED_INT_10_10_10_2,
  UNSIGNED_INT_2_10_10_10_REV = GL_UNSIGNED_INT_2_10_10_10_REV,
};

// FRAMEBUFFER

enum class FramebufferAttachment : uint32_t {
  COLOR_ATTACHMENT_0 = GL_COLOR_ATTACHMENT0,
  COLOR_ATTACHMENT_1 = GL_COLOR_ATTACHMENT1,
  COLOR_ATTACHMENT_2 = GL_COLOR_ATTACHMENT2,
  COLOR_ATTACHMENT_3 = GL_COLOR_ATTACHMENT3,
  COLOR_ATTACHMENT_4 = GL_COLOR_ATTACHMENT4,
  COLOR_ATTACHMENT_5 = GL_COLOR_ATTACHMENT5,
  COLOR_ATTACHMENT_6 = GL_COLOR_ATTACHMENT6,
  COLOR_ATTACHMENT_7 = GL_COLOR_ATTACHMENT7,
  COLOR_ATTACHMENT_8 = GL_COLOR_ATTACHMENT8,
  COLOR_ATTACHMENT_9 = GL_COLOR_ATTACHMENT9,
  COLOR_ATTACHMENT_10 = GL_COLOR_ATTACHMENT10,
  COLOR_ATTACHMENT_11 = GL_COLOR_ATTACHMENT11,
  COLOR_ATTACHMENT_12 = GL_COLOR_ATTACHMENT12,
  COLOR_ATTACHMENT_13 = GL_COLOR_ATTACHMENT13,
  COLOR_ATTACHMENT_14 = GL_COLOR_ATTACHMENT14,
  COLOR_ATTACHMENT_15 = GL_COLOR_ATTACHMENT15,
  COLOR_ATTACHMENT_16 = GL_COLOR_ATTACHMENT16,
  COLOR_ATTACHMENT_17 = GL_COLOR_ATTACHMENT17,
  COLOR_ATTACHMENT_18 = GL_COLOR_ATTACHMENT18,
  COLOR_ATTACHMENT_19 = GL_COLOR_ATTACHMENT19,
  COLOR_ATTACHMENT_20 = GL_COLOR_ATTACHMENT20,
  COLOR_ATTACHMENT_21 = GL_COLOR_ATTACHMENT21,
  COLOR_ATTACHMENT_22 = GL_COLOR_ATTACHMENT22,
  COLOR_ATTACHMENT_23 = GL_COLOR_ATTACHMENT23,
  COLOR_ATTACHMENT_24 = GL_COLOR_ATTACHMENT24,
  COLOR_ATTACHMENT_25 = GL_COLOR_ATTACHMENT25,
  COLOR_ATTACHMENT_26 = GL_COLOR_ATTACHMENT26,
  COLOR_ATTACHMENT_27 = GL_COLOR_ATTACHMENT27,
  COLOR_ATTACHMENT_28 = GL_COLOR_ATTACHMENT28,
  COLOR_ATTACHMENT_29 = GL_COLOR_ATTACHMENT29,
  COLOR_ATTACHMENT_30 = GL_COLOR_ATTACHMENT30,
  COLOR_ATTACHMENT_31 = GL_COLOR_ATTACHMENT31,
  DEPTH_ATTACHMENT = GL_DEPTH_ATTACHMENT,
  STENCIL_ATTACHMENT = GL_STENCIL_ATTACHMENT,
  DEPTH_STENCIL_ATTACHMENT = GL_DEPTH_STENCIL_ATTACHMENT
};

enum class FramebufferStatus : uint32_t {
  FRAMEBUFFER_COMPLETE = GL_FRAMEBUFFER_COMPLETE,
  FRAMEBUFFER_UNDEFINED = GL_FRAMEBUFFER_UNDEFINED,
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT = GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT,
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT,
  FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER,
  FRAMEBUFFER_INCOMPLETE_READ_BUFFER = GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER,
  FRAMEBUFFER_UNSUPPORTED = GL_FRAMEBUFFER_UNSUPPORTED,
  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE,
  FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS
};

enum class FramebufferTarget : uint32_t {
  DRAW_FRAMEBUFFER = GL_DRAW_FRAMEBUFFER,
  READ_FRAMEBUFFER = GL_READ_FRAMEBUFFER,
  FRAMEBUFFER = GL_FRAMEBUFFER
};

// DRAW

enum class PrimitiveKind : uint32_t {
  POINTS = GL_POINTS,
  LINE_STRIP = GL_LINE_STRIP,
  LINE_LOOP = GL_LINE_LOOP,
  LINES = GL_LINES,
  LINE_STRIP_ADJACENCY = GL_LINE_STRIP_ADJACENCY,
  LINES_ADJACENCY = GL_LINES_ADJACENCY,
  TRIANGLE_STRIP = GL_TRIANGLE_STRIP,
  TRIANGLE_FAN = GL_TRIANGLE_FAN,
  TRIANGLES = GL_TRIANGLES,
  TRIANGLE_STRIP_ADJACENCY = GL_TRIANGLE_STRIP_ADJACENCY,
  TRIANGLES_ADJACENCY = GL_TRIANGLES_ADJACENCY,
  PATCHES = GL_PATCHES
};

enum class DrawElementType {
  UNSIGNED_BYTE = GL_UNSIGNED_BYTE,
  UNSIGNED_SHORT = GL_UNSIGNED_SHORT,
  UNSIGNED_INT = GL_UNSIGNED_INT
};

enum class ClearBufferMaskBit {
  COLOR = GL_COLOR_BUFFER_BIT,
  DEPTH = GL_DEPTH_BUFFER_BIT,
  STENCIL = GL_STENCIL_BUFFER_BIT
};

// OPTIONS

enum class Capability {
  BLEND = GL_BLEND,
  CLIP_DISTANCE_0 = GL_CLIP_DISTANCE0,
  CLIP_DISTANCE_1 = GL_CLIP_DISTANCE1,
  CLIP_DISTANCE_2 = GL_CLIP_DISTANCE2,
  CLIP_DISTANCE_3 = GL_CLIP_DISTANCE3,
  CLIP_DISTANCE_4 = GL_CLIP_DISTANCE4,
  CLIP_DISTANCE_5 = GL_CLIP_DISTANCE5,
  CLIP_DISTANCE_6 = GL_CLIP_DISTANCE6,
  CLIP_DISTANCE_7 = GL_CLIP_DISTANCE7,
  COLOR_LOGIC_OP = GL_COLOR_LOGIC_OP,
  CULL_FACE = GL_CULL_FACE,
  DEBUG_OUTPUT = GL_DEBUG_OUTPUT,
  DEBUG_OUTPUT_SYNCHRONOUS = GL_DEBUG_OUTPUT_SYNCHRONOUS,
  DEPTH_CLAMP = GL_DEPTH_CLAMP,
  DEPTH_TEST = GL_DEPTH_TEST,
  DITHER = GL_DITHER,
  FRAMEBUFFER_SRGB = GL_FRAMEBUFFER_SRGB,
  LINE_SMOOTH = GL_LINE_SMOOTH,
  MULTISAMPLE = GL_MULTISAMPLE,
  POLYGON_OFFSET_FILL = GL_POLYGON_OFFSET_FILL,
  POLYGON_OFFSET_LINE = GL_POLYGON_OFFSET_LINE,
  POLYGON_OFFSET_POINT = GL_POLYGON_OFFSET_POINT,
  POLYGON_SMOOTH = GL_POLYGON_SMOOTH,
  PRIMITIVE_RESTART = GL_PRIMITIVE_RESTART,
  PRIMITIVE_RESTART_FIXED_INDEX = GL_PRIMITIVE_RESTART_FIXED_INDEX,
  RASTERIZER_DISCARD = GL_RASTERIZER_DISCARD,
  SAMPLE_ALPHA_TO_COVERAGE = GL_SAMPLE_ALPHA_TO_COVERAGE,
  SAMPLE_ALPHA_TO_ONE = GL_SAMPLE_ALPHA_TO_ONE,
  SAMPLE_COVERAGE = GL_SAMPLE_COVERAGE,
  SAMPLE_SHADING = GL_SAMPLE_SHADING,
  SAMPLE_MASK = GL_SAMPLE_MASK,
  SCISSOR_TEST = GL_SCISSOR_TEST,
  STENCIL_TEST = GL_STENCIL_TEST,
  TEXTURE_CUBE_MAP_SEAMLESS = GL_TEXTURE_CUBE_MAP_SEAMLESS,
  PROGRAM_POINT_SIZE = GL_PROGRAM_POINT_SIZE
};

enum class BlendEquationMode : uint32_t {
  FUNC_ADD = GL_FUNC_ADD,
  FUNC_SUBTRACT = GL_FUNC_SUBTRACT,
  FUNC_REVERSE_SUBTRACT = GL_FUNC_REVERSE_SUBTRACT,
  MIN = GL_MIN,
  MAX = GL_MAX
};

enum class BlendFunction : uint32_t {
  ZERO = GL_ZERO,
  ONE = GL_ONE,
  SRC_COLOR = GL_SRC_COLOR,
  ONE_MINUS_SRC_COLOR = GL_ONE_MINUS_SRC_COLOR,
  DST_COLOR = GL_DST_COLOR,
  ONE_MINUS_DST_COLOR = GL_ONE_MINUS_DST_COLOR,
  SRC_ALPHA = GL_SRC_ALPHA,
  ONE_MINUS_SRC_ALPHA = GL_ONE_MINUS_SRC_ALPHA,
  DST_ALPHA = GL_DST_ALPHA,
  ONE_MINUS_DST_ALPHA = GL_ONE_MINUS_DST_ALPHA,
  CONSTANT_COLOR = GL_CONSTANT_COLOR,
  ONE_MINUS_CONSTANT_COLOR = GL_ONE_MINUS_CONSTANT_COLOR,
  CONSTANT_ALPHA = GL_CONSTANT_ALPHA,
  ONE_MINUS_CONSTANT_ALPHA = GL_ONE_MINUS_CONSTANT_ALPHA,
  SRC_ALPHA_SATURATE = GL_SRC_ALPHA_SATURATE,
  SRC1_COLOR = GL_SRC1_COLOR,
  ONE_MINUS_SRC1_COLOR = GL_ONE_MINUS_SRC1_COLOR,
  SRC1_ALPHA = GL_SRC1_ALPHA,
  ONE_MINUS_SRC1_ALPHA = GL_ONE_MINUS_SRC1_ALPHA
};

enum class DepthFunction : uint32_t {
  NEVER = GL_NEVER,
  LESS = GL_LESS,
  EQUAL = GL_EQUAL,
  LEQUAL = GL_LEQUAL,
  GREATER = GL_GREATER,
  NOTEQUAL = GL_NOTEQUAL,
  GEQUAL = GL_GEQUAL,
  ALWAYS = GL_ALWAYS
};

enum class FrontFaceDirection : uint32_t {
  CW = GL_CW,
  CCW = GL_CCW
};

enum class TriangleFace {
  FRONT = GL_FRONT,
  BACK = GL_BACK,
  FRONT_AND_BACK = GL_FRONT_AND_BACK
};

// PROGRAM

enum class ShaderType : uint32_t {
  COMPUTE = GL_COMPUTE_SHADER,
  VERTEX = GL_VERTEX_SHADER,
  TESSELLATION_CONTROL = GL_TESS_CONTROL_SHADER,
  TESSELLATION_EVALUATION = GL_TESS_EVALUATION_SHADER,
  GEOMETRY = GL_GEOMETRY_SHADER,
  FRAGMENT = GL_FRAGMENT_SHADER
};

enum class ShaderParameterName : uint32_t {
  SHADER_TYPE = GL_SHADER_TYPE,
  DELETE_STATUS = GL_DELETE_STATUS,
  COMPILE_STATUS = GL_COMPILE_STATUS,
  INFO_LOG_LENGTH = GL_INFO_LOG_LENGTH,
  SHADER_SOURCE_LENGTH = GL_SHADER_SOURCE_LENGTH
};

enum class ProgramParameterName : uint32_t {
  DELETE_STATUS = GL_DELETE_STATUS,
  LINK_STATUS = GL_LINK_STATUS,
  VALIDATE_STATUS = GL_VALIDATE_STATUS,
  INFO_LOG_LENGTH = GL_INFO_LOG_LENGTH,
  ATTACHED_SHADERS = GL_ATTACHED_SHADERS,
  ACTIVE_ATTRIBUTES = GL_ACTIVE_ATTRIBUTES,
  ACTIVE_ATTRIBUTE_MAX_LENGTH = GL_ACTIVE_ATTRIBUTE_MAX_LENGTH,
  ACTIVE_UNIFORMS = GL_ACTIVE_UNIFORMS,
  ACTIVE_UNIFORM_MAX_LENGTH = GL_ACTIVE_UNIFORM_MAX_LENGTH
};

enum class ProgramInterface : uint32_t {
  UNIFORM = GL_UNIFORM,
  UNIFORM_BLOCK = GL_UNIFORM_BLOCK,
  ATOMIC_COUNTER_BUFFER = GL_ATOMIC_COUNTER_BUFFER,
  PROGRAM_INPUT = GL_PROGRAM_INPUT,
  PROGRAM_OUTPUT = GL_PROGRAM_OUTPUT,
  VERTEX_SUBROUTINE = GL_VERTEX_SUBROUTINE,
  TESSELLATION_CONTROL_SUBROUTINE = GL_TESS_CONTROL_SUBROUTINE,
  TESSELLATION_EVALUATION_SUBROUTINE = GL_TESS_EVALUATION_SUBROUTINE,
  GEOMETRY_SUBROUTINE = GL_GEOMETRY_SUBROUTINE,
  FRAGMENT_SUBROUTINE = GL_FRAGMENT_SUBROUTINE,
  COMPUTE_SUBROUTINE = GL_COMPUTE_SUBROUTINE,
  VERTEX_SUBROUTINE_UNIFORM = GL_VERTEX_SUBROUTINE_UNIFORM,
  TESSELLATION_CONTROL_SUBROUTINE_UNIFORM = GL_TESS_CONTROL_SUBROUTINE_UNIFORM,
  TESSELLATION_EVALUATION_SUBROUTINE_UNIFORM = GL_TESS_EVALUATION_SUBROUTINE_UNIFORM,
  GEOMETRY_SUBROUTINE_UNIFORM = GL_GEOMETRY_SUBROUTINE_UNIFORM,
  FRAGMENT_SUBROUTINE_UNIFORM = GL_FRAGMENT_SUBROUTINE_UNIFORM,
  COMPUTE_SUBROUTINE_UNIFORM = GL_COMPUTE_SUBROUTINE_UNIFORM,
  TRANSFORM_FEEDBACK_VARYING = GL_TRANSFORM_FEEDBACK_VARYING,
  BUFFER_VARIABLE = GL_BUFFER_VARIABLE,
  SHADER_STORAGE_BLOCK = GL_SHADER_STORAGE_BLOCK,
  TRANSFORM_FEEDBACK_BUFFER = GL_TRANSFORM_FEEDBACK_BUFFER
};

enum class ProgramInterfaceParameterName : uint32_t {
  ACTIVE_RESOURCES = GL_ACTIVE_RESOURCES,
  MAX_NAME_LENGTH = GL_MAX_NAME_LENGTH,
  MAX_NUM_ACTIVE_VARIABLES = GL_MAX_NUM_ACTIVE_VARIABLES,
  MAX_NUM_COMPATIBLE_SUBROUTINES = GL_MAX_NUM_COMPATIBLE_SUBROUTINES
};

enum class ProgramResourceProperty : uint32_t {
  NAME_LENGTH = GL_NAME_LENGTH,
  TYPE = GL_TYPE,
  ARRAY_SIZE = GL_ARRAY_SIZE,
  OFFSET = GL_OFFSET,
  BLOCK_INDEX = GL_BLOCK_INDEX,
  ARRAY_STRIDE = GL_ARRAY_STRIDE,
  MATRIX_STRIDE = GL_MATRIX_STRIDE,
  IS_ROW_MAJOR = GL_IS_ROW_MAJOR,
  ATOMIC_COUNTER_BUFFER_INDEX = GL_ATOMIC_COUNTER_BUFFER_INDEX,
  TEXTURE_BUFFER = GL_TEXTURE_BUFFER,
  BUFFER_BINDING = GL_BUFFER_BINDING,
  BUFFER_DATA_SIZE = GL_BUFFER_DATA_SIZE,
  NUMBER_ACTIVE_VARIABLES = GL_NUM_ACTIVE_VARIABLES,
  ACTIVE_VARIABLES = GL_ACTIVE_VARIABLES,
  REFERENCED_BY_VERTEX_SHADER = GL_REFERENCED_BY_VERTEX_SHADER,
  REFERENCED_BY_TESSELLATION_CONTROL_SHADER = GL_REFERENCED_BY_TESS_CONTROL_SHADER,
  REFERENCED_BY_TESSELLATION_EVALUATION_SHADER = GL_REFERENCED_BY_TESS_EVALUATION_SHADER,
  REFERENCED_BY_GEOMETRY_SHADER = GL_REFERENCED_BY_GEOMETRY_SHADER,
  REFERENCED_BY_FRAGMENT_SHADER = GL_REFERENCED_BY_FRAGMENT_SHADER,
  REFERENCED_BY_COMPUTE_SHADER = GL_REFERENCED_BY_COMPUTE_SHADER,
  NUMBER_COMPATIBLE_SUBROUTINES = GL_NUM_COMPATIBLE_SUBROUTINES,
  COMPATIBLE_SUBROUTINES = GL_COMPATIBLE_SUBROUTINES,
  TOP_LEVEL_ARRAY_SIZE = GL_TOP_LEVEL_ARRAY_SIZE,
  TOP_LEVEL_ARRAY_STRIDE = GL_TOP_LEVEL_ARRAY_STRIDE,
  LOCATION = GL_LOCATION,
  LOCATION_INDEX = GL_LOCATION_INDEX,
  IS_PER_PATCH = GL_IS_PER_PATCH,
  LOCATION_COMPONENT = GL_LOCATION_COMPONENT,
  TRANSFORM_FEEDBACK_BUFFER_INDEX = GL_TRANSFORM_FEEDBACK_BUFFER_INDEX,
  TRANSFORM_FEEDBACK_BUFFER_STRIDE = GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE
};

// BARRIER

enum class MemoryBarrierMaskBit {
  VERTEX_ATTRIB_ARRAY = GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT,
  ELEMENT_ARRAY = GL_ELEMENT_ARRAY_BARRIER_BIT,
  UNIFORM = GL_UNIFORM_BARRIER_BIT,
  TEXTURE_FETCH = GL_TEXTURE_FETCH_BARRIER_BIT,
  SHADER_IMAGE_ACCESS = GL_SHADER_IMAGE_ACCESS_BARRIER_BIT,
  COMMAND = GL_COMMAND_BARRIER_BIT,
  PIXEL_BUFFER = GL_PIXEL_BUFFER_BARRIER_BIT,
  TEXTURE_UPDATE = GL_TEXTURE_UPDATE_BARRIER_BIT,
  BUFFER_UPDATE = GL_BUFFER_UPDATE_BARRIER_BIT,
  FRAMEBUFFER = GL_FRAMEBUFFER_BARRIER_BIT,
  TRANSFORM_FEEDBACK = GL_TRANSFORM_FEEDBACK_BARRIER_BIT,
  ATOMIC_COUNTER = GL_ATOMIC_COUNTER_BARRIER_BIT,
  SHADER_STORAGE = GL_SHADER_STORAGE_BARRIER_BIT
};

enum class MemoryBarrierRegionMaskBit {
  ATOMIC_COUNTER = GL_ATOMIC_COUNTER_BARRIER_BIT,
  FRAMEBUFFER = GL_FRAMEBUFFER_BARRIER_BIT,
  SHADER_IMAGE_ACCESS = GL_SHADER_IMAGE_ACCESS_BARRIER_BIT,
  SHADER_STORAGE = GL_SHADER_STORAGE_BARRIER_BIT,
  TEXTURE_FETCH = GL_TEXTURE_FETCH_BARRIER_BIT,
  UNIFORM = GL_UNIFORM_BARRIER_BIT
};

enum class BufferAccess : uint32_t {
  READ_ONLY = GL_READ_ONLY,
  WRITE_ONLY = GL_WRITE_ONLY,
  READ_WRITE = GL_READ_WRITE
};

// STRUCTURES

struct Pixel {
  PixelFormat format;
  PixelType type;
};

// FUNCTIONS

ErrorCode GetErrorCode(uint32_t error_code);

// VERTEX ARRAY
VertexAttributeType GetVertexAttributeType(AttributeType type);
uint32_t GetAttributeComponentsCount(AttributeType type);
uint32_t GetVertexAttributeSize(VertexAttributeType type);
uint32_t GetAttributeSize(AttributeType type);
uint32_t GetStride(std::span<const AttributeType> types);

// TEXTURE
uint32_t GetTextureDimensions(TextureTarget texture_target);
const Pixel &GetFormatInformation(InternalFormat internal_format);

// STRING TOOLS
std::string_view ToString(AttributeType attribute_type);
std::string_view ToString(ErrorCode error_code);

// MASKS
using MapBufferAccessMask = Mask<MapBufferAccessMaskBit>;
using BufferStorageMask = Mask<BufferStorageMaskBit>;
using ClearBufferMask = Mask<ClearBufferMaskBit>;
using MemoryBarrierMask = Mask<MemoryBarrierMaskBit>;
using MemoryBarrierRegionMask = Mask<MemoryBarrierRegionMaskBit>;

} // namespace Terabithia

#endif // TERABITHIA_GRAPHICS_TYPES_H